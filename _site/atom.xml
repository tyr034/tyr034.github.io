<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>BeiYuu.com</title>
   <link href="http://beiyuu.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://beiyuu.com" rel="alternate" type="text/html" />
   <updated>2015-04-15T20:39:59-04:00</updated>
   <id>http://beiyuu.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Elements of Algorithms</title>
     <link href="http://beiyuu.com/Elements-Of-Algorithm"/>
     <updated>2014-08-09T00:00:00-04:00</updated>
     <id>http://beiyuu.com/Elements-Of-Algorithm</id>
     <content type="html">&lt;h2&gt;Introduction:&lt;/h2&gt;

&lt;p&gt;There are infinite problems out there waiting to be solved. The only thing we could do is to seize the
unchang: Basics Elements of Algorithms.&lt;/p&gt;

&lt;h2&gt;Principles:&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt; There should be one (and preferably only one) obvious way to do it &lt;/li&gt;
    &lt;li&gt; If the implementation is hard to explain, it&#39;s a bad idea &lt;/li&gt; 
&lt;/ul&gt;


&lt;h2&gt;Elements:&lt;/h2&gt;

&lt;h3&gt;Two Pointers:&lt;/h3&gt;

&lt;p&gt; 2Sum/3sum/4Sum..., Intersection of Two Lists, Valid Palindrome, Linked List Cycle, Sorting and Rearranging of a List&lt;/p&gt;

&lt;h3&gt;Binary Search:&lt;/h3&gt;

&lt;p&gt;sqrt(x), pow(x,y),Median of Two Sorted Array, Search in Rotated Sorted Array&lt;/p&gt;

&lt;h3&gt;For Loop and Recursion (Backtracking):&lt;/h3&gt;

&lt;p&gt;Depth-first Search, All Kinds of Path Problems in Tree, Surroned region in a Matrix, Permutations, Combinations, Subsets.&lt;/p&gt;

&lt;h3&gt;Dynamic Programming:&lt;/h3&gt;

&lt;p&gt;Maximum Subarray, Buy and Sell Stock&lt;/p&gt;

&lt;h3&gt;Useful Data Structures:&lt;/h3&gt;

&lt;h4&gt;HashTable:&lt;/h4&gt;

&lt;p&gt;the single most important data structure when you need a O(1) lookup&lt;/p&gt;

&lt;h4&gt;Queue/Stack:&lt;/h4&gt;

&lt;p&gt;when you need to maintain certain order: Find the first non-repeating characters in a string;&lt;/p&gt;

&lt;h4&gt;Priority Queue/ Heap:&lt;/h4&gt;

&lt;p&gt;merge K sorted List&lt;/p&gt;

&lt;h4&gt;Prefix Tree&lt;/h4&gt;
</content>
   </entry>
   
   <entry>
     <title> How to Set Up Your PATH Enviroment On Mac OSX</title>
     <link href="http://beiyuu.com/welcome-to-jekyll"/>
     <updated>2014-07-31T00:00:00-04:00</updated>
     <id>http://beiyuu.com/welcome-to-jekyll</id>
     <content type="html">&lt;h2&gt;.bash_profile&lt;/h2&gt;

&lt;p&gt;Have you ever wondered that when you type in commonad, like $ python in a terminal. How does your system know the meaning of python and the path of commoand $ python. All the magics lie
in a shell script called .bash_profile.(for the
difference between .bash_profile and .bashrc,
go to this page for &lt;a href=&quot;http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html&quot;&gt;details&lt;/a&gt;)
Basically, this script get excuted everytime when you start a log in shell and tell the system
where to find the path.&lt;/p&gt;

&lt;h2&gt;Set Up Environment&lt;/h2&gt;

&lt;p&gt;I first encountered with this question when I tried
to use maven for my project.It had a hard time finding path for java sdk. I checked out all kinds of resources online trying to figure out the correct syntax to set path in bash_profile and
it was so painful. At the end, I figured out two
ways fo set up path,&lt;/p&gt;

&lt;p&gt;the first one is:
&lt;code&gt;
PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.4/bin:${PATH}&quot;
PATH=&quot;/Users/taoyiran/apache-maven-3.2.2/bin:${PATH}&quot;
PATH=&quot;/usr/local/:mysql/bin:${PATH}&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;the other one is:
&lt;code&gt;
export JAVA_HOME=/usr/libexec/java_home
export TOMCAT_HOME=/usr/local/apache-tomcat-7.0.50
export ECLIPSE_HOME=/usr/local/eclipse
export M2_HOME=/usr/local/apache-maven-3.1.1
export MYSQL_HOME=/usr/local/mysql-5.6.14-osx10.7-x86_64
export PATH=$JAVA_HOME/bin:$ECLIPSE_HOME:$M2_HOME/bin:$MYSQL_HOME/bin:$TOMCAT_HOME/bin:$PATH
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Hope this will help you !&lt;/p&gt;

&lt;h2&gt;ok&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>CSS3动画详解</title>
     <link href="http://beiyuu.com/css3-animation"/>
     <updated>2013-08-24T00:00:00-04:00</updated>
     <id>http://beiyuu.com/css3-animation</id>
     <content type="html">&lt;h2&gt;CSS3动画&lt;/h2&gt;

&lt;p&gt;有人认为CSS动画是做了js的事情，较真起来也算，只是已经抢占许多年了，早些年要实现鼠标滑过链接变色的基本效果，需要动用Java Applet，后来只需给HTML元素加事件&lt;code&gt;onclick=changecolor()&lt;/code&gt;，再之后正如你所知，只要写&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:focus&lt;/code&gt;这样的伪类即可，同样的，现在有了CSS3动画。&lt;/p&gt;

&lt;h4&gt;CSS3动画的优势：&lt;/h4&gt;

&lt;ul&gt;
    &lt;li&gt;写起来非常方便，不会js也没问题&lt;/li&gt;
    &lt;li&gt;有些动画js也不能很好的胜任，比如让一个元素在二维、三维空间旋转&lt;/li&gt;
    &lt;li&gt;运行效果流畅，让浏览器去优化性能&lt;/li&gt;
    &lt;li&gt;浏览器从底层优化动画序列，例如当tab不可见的时候，降低更新的频率提高整体性能&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;劣势：&lt;/h4&gt;

&lt;ul&gt;
    &lt;li&gt;CSS3动画应用的范围还是有限&lt;/li&gt;
    &lt;li&gt;兼容性：对于增强体验的Feature来说，可以无视&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;可以做动画效果的属性&lt;/h3&gt;

&lt;p&gt;理论上来说，任何单独的CSS属性都可以做动画的效果，比如：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;width&lt;/code&gt;：10px 到 100px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;padding&lt;/code&gt;：0px 到 20px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;color&lt;/code&gt;：#F00 到 #00F&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;top&lt;/code&gt;：0px 到 10px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;border-radius&lt;/code&gt;：3px 到 8px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;transform&lt;/code&gt;：rotate(0deg) 到 ratate(45deg)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;你也可以给&lt;code&gt;red&lt;/code&gt;、&lt;code&gt;blue&lt;/code&gt;这样的赋值的颜色属性加transition或animation，它会被自动转化为对应的RGB值。&lt;/p&gt;

&lt;h3&gt;不可以做动画效果的属性&lt;/h3&gt;

&lt;p&gt;看下面这些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p {
    display: none;
    transition: all 3s ease;
}

#container:hover p {
    display: block;
}

/**********************/

#container p {
    height: 0px;
    transition: all 3s ease;
}

#container:hover p {
    height: auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性从无到有或到不确定值，动画效果不会生效，因为浏览器不知道如何去做，对于元素从无到有，你可以选择&lt;code&gt;opacity&lt;/code&gt;属性来处理。&lt;/p&gt;

&lt;h2&gt;CSS3 Transition&lt;/h2&gt;

&lt;p&gt;Transition是被用到最多的也是最简单的CSS3动画类型。如果要做一个10px宽的蓝色元素在3s后变成一个100px宽的红色元素的效果，Transition可以平滑实现，你只需要声明起始和终止这两个状态。&lt;/p&gt;

&lt;p&gt;Transition的触发也很简单，可以用&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:focus&lt;/code&gt;这样的伪类来触发，也可以通过改变元素的样式来触发。&lt;/p&gt;

&lt;h3&gt;transition的属性&lt;/h3&gt;

&lt;h4&gt;transition-property&lt;/h4&gt;

&lt;p&gt;transition-property用来声明transition会被应用到的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-property: color;
}

#container p.two {
    transition-property: width;
}

#container p.three {
    transition-property: color, width;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想应用到所有属性，那可以简单写作&lt;code&gt;all&lt;/code&gt;，也可以通过&lt;code&gt;none&lt;/code&gt;来关闭transition。&lt;/p&gt;

&lt;h4&gt;transition-duration&lt;/h4&gt;

&lt;p&gt;transition-duration用来声明动画持续的时长，可以是s也可以是ms&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-duration: 3s;
}

#container p.two {
    transition-duration: 3000ms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;transition-timing-function&lt;/h4&gt;

&lt;p&gt;transition-timing-function声明了动画的缓动类型，有下面几个选项：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;ease&lt;/code&gt;：默认项，动画效果慢慢开始然后加速，到中点后再减速最后缓慢到达终点&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-in-out&lt;/code&gt;：与ease类似，加减速更柔和一些&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-in&lt;/code&gt;：开始比较慢，但是加速和停止曲线比较陡峭&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-out&lt;/code&gt;：开始较快，然后缓慢停止&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;linear&lt;/code&gt;：线性平均速率，通常在color和opacity属性的变化上&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最后，还有&lt;code&gt;cubic-bezier&lt;/code&gt;函数，可以自己创造更多更优美的缓动类型。&lt;/p&gt;

&lt;h4&gt;transition-delay&lt;/h4&gt;

&lt;p&gt;transition-delay声明了动画延迟开始的时间，很容易理解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-delay: 0.5s;
}

#container p.two {
    transition-delay: 500ms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;transition简写&lt;/h3&gt;

&lt;p&gt;上面介绍了transition的属性，他们也可以合并成一项，省去了许多拼写，当然也别忘记浏览器前缀：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p {
    transition-property: all;
    transition-duration: 3s;
    transition-timing-function: ease-in-out;
    transition-delay: 0.5s;
}


#element {
    /* starting state styles */
    color: #F00;
    -webkit-transition: all 3s ease-in-out 0.5s;
    transition: all 3s ease-in-out 0.5s;
}

#element:hover {
    /* ending state styles */
    color: #00F;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;transition的高级用法&lt;/h3&gt;

&lt;h4&gt;不同的transition效果&lt;/h4&gt;

&lt;p&gt;看这样的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    color: #ff6;
    transition: all 3s ease-in-out 0.5s;
}

p#animate:hover {
    color: #0f0;
    transform: scale(4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，当鼠标hover，元素在0.5s之后在3s内放大四倍，鼠标移开，需要同样的时间回到原来的状态。如果想要不同的效果，可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    color: #ff6;
    transition: all 0.5s ease-in-out;
}

p#animate:hover {
    color: #0f0;
    transform: scale(4);
    transition: all 3s ease-in-out 0.5s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;多个transition&lt;/h4&gt;

&lt;p&gt;需要给多个transition指定不同的效果时，&lt;code&gt;all&lt;/code&gt;属性解决不了，可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    width: 10em;
    background-color: #F00;
    border-radius: 5px;
    transition-property: width, border-radius, background-color;
    transition-duration: 1s, 2s;
    transition-timing-function:  ease, ease-out, linear;
}

p#animate:hover {
    width: 20em;
    background-color: #00F;
    border-radius: 50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的&lt;code&gt;transition-duration&lt;/code&gt;只写了两个，那么第三个&lt;code&gt;transition-property&lt;/code&gt;属性&lt;code&gt;background-color&lt;/code&gt;就用循环到第一个，也就是说他的&lt;code&gt;transition-duration&lt;/code&gt;值是&lt;code&gt;1s&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;transition示例&lt;/h3&gt;

&lt;div id=&quot;transition1&quot;&gt;
#transition1 {&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;width:350px;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:#1abc9c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-propety:width,background-color;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-duration:.5s, 1s;&lt;br&gt;
}&lt;br&gt;
#transition1:hover {&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;width:450px;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:#8e44ad;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-duration:.5s, 3s;&lt;br&gt;
}&lt;br&gt;
&lt;/div&gt;


&lt;h2&gt;CSS3 Animation&lt;/h2&gt;

&lt;h3&gt;Animation和Transition的不同&lt;/h3&gt;

&lt;ul&gt;
    &lt;li&gt;和transition一样都可以定义开始和结束状态，但是animation还可以指定更确定的中间状态&lt;/li&gt;
    &lt;li&gt;animation可以像transition一样被触发，也可以自动运行&lt;/li&gt;
    &lt;li&gt;animation可以无限循环的运行下去，也可以指定运行的次数&lt;/li&gt;
    &lt;li&gt;animation可以在顺序运行也可以反向运行&lt;/li&gt;
    &lt;li&gt;animatino写起来稍麻烦些，但是依然比js简单许多&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;定义keyframes&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@keyframes colorchange {
    0%   { background-color: #00F; /* from: blue */ }
    25%  { background-color: #F00; /* red        */ }
    50%  { background-color: #0F0; /* green      */ }
    75%  { background-color: #F0F; /* purple     */ }
    100% { background-color: #00F; /* to: blue   */ }
}

@-webkit-keyframes colorchange {
    0%   { background-color: #00F; /* from: blue */ }
    25%  { background-color: #F00; /* red        */ }
    50%  { background-color: #0F0; /* green      */ }
    75%  { background-color: #F0F; /* purple     */ }
    100% { background-color: #00F; /* to: blue   */ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，只是定义了&lt;code&gt;background-color&lt;/code&gt;这一个属性，如有需要，可以换做其他。对于&lt;code&gt;0%&lt;/code&gt;这个也可以用&lt;code&gt;from&lt;/code&gt;关键字来替代，同样的可以用&lt;code&gt;to&lt;/code&gt;来代替&lt;code&gt;100%&lt;/code&gt;，过渡状态，你可以定义任何百分比，类似&lt;code&gt;12.5%&lt;/code&gt;这样的也可以，不过就不用给自己找麻烦了吧。浏览器的&lt;code&gt;prefix&lt;/code&gt;也不能少。&lt;/p&gt;

&lt;h3&gt;应用到元素&lt;/h3&gt;

&lt;p&gt;将&lt;code&gt;animation&lt;/code&gt;应用到元素的属性写法，和&lt;code&gt;transition&lt;/code&gt;差不太多，顺序都一致，就不在一个个参数重复说明，直接看代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#myelement {
    animation-name: colorchange; /**这里引用了前面定义的动画**/
    animation-duration: 5s;
    animation-timing-function: linear;
    animation-delay: 1s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
}

/****简写****/
#myelement {
    -webkit-animation: colorchange 5s linear 1s infinite alternate;
    animation: colorchange 5s linear 1s infinite alternate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;animation-iteration-count&lt;/code&gt;用来指定动画循环的次数，无限循环用&lt;code&gt;infinite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;animation-direction有四个值：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;normal&lt;/code&gt;：默认，从0%执行到100%&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;reverse&lt;/code&gt;：动画从100%执行到0%&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;alternate&lt;/code&gt;：动画在0%到100%之间往复执行&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;alternate-reverse&lt;/code&gt;与&lt;code&gt;alternate&lt;/code&gt;一致，不过是从100%开始&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Animation示例&lt;/h3&gt;

&lt;div id=&quot;ani1&quot;&gt;Animate color&lt;/div&gt;


&lt;h2&gt;CSS3 Transform&lt;/h2&gt;

&lt;p&gt;有了&lt;code&gt;transition&lt;/code&gt;和&lt;code&gt;animation&lt;/code&gt;之后，就可以做出些漂亮的动画效果，如果再搭配&lt;code&gt;transform&lt;/code&gt;这一CSS3动画利器，就更出彩了。&lt;/p&gt;

&lt;h3&gt;CSS3 2D Transform&lt;/h3&gt;

&lt;p&gt;运用CSS3 2D Transform的技术，可以更自由轻松的来修饰HTML元素。CSS3 2D Transform的基本方法有下面这些：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;translate()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scale()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;skew()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;matrix()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;Translate&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;translate()&lt;/code&gt;方法，可以将HTML元素在x-y轴平面上做位移，且不会影响到其他元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div{
    -webkit-transform: translate(20px,20px);
    -moz-transform: translate(20px,20px);
    -o-transform: translate(20px,20px);
    transform: translate(20px,20px);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;div id=&quot;translate1&quot;&gt;
&lt;div id=&quot;trans-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;trans-inner2&quot;&gt;transform:tranlated(40px, 40px)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Rotate&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;rotate()&lt;/code&gt;方法可以将元素按照时钟方向旋转，参数可以是&lt;code&gt;0deg&lt;/code&gt;到&lt;code&gt;360deg&lt;/code&gt;，也是在x-y轴平面，示例如下：&lt;/p&gt;

&lt;div id=&quot;rotate1&quot;&gt;
&lt;div id=&quot;rota-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;rota-inner2&quot;&gt;transform:rotate(-30deg)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Scale&lt;/h4&gt;

&lt;p&gt;和名字的一样，&lt;code&gt;scale()&lt;/code&gt;方法用来放大一个元素，依然是在x-y轴平面，看示例：&lt;/p&gt;

&lt;div id=&quot;scale1&quot;&gt;
    &lt;div id=&quot;sca-inner1&quot;&gt;Normal Div&lt;/div&gt;
    &lt;div id=&quot;sca-inner2&quot;&gt;transform:scale(1.5,1.3)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Skew&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;skew()&lt;/code&gt;方法可以将元素按照指定参数进行扭曲，你需要指定x、y轴的扭曲角度，看示例：&lt;/p&gt;

&lt;div id=&quot;skew1&quot;&gt;
&lt;div id=&quot;sk-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;sk-inner2&quot;&gt;transform:skew(30deg,0)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Matrix&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;matrix()&lt;/code&gt;方法是以上所有2D效果的方法的总和，写法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div{
    transform: matrix(a,b,c,d,tx,ty);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上&lt;code&gt;scale&lt;/code&gt;、&lt;code&gt;skew&lt;/code&gt;、&lt;code&gt;rotate&lt;/code&gt;、&lt;code&gt;translate&lt;/code&gt;的效果都是通过&lt;code&gt;matrix&lt;/code&gt;实现的，&lt;code&gt;tx&lt;/code&gt;、&lt;code&gt;ty&lt;/code&gt;表示位移量，关于&lt;code&gt;matrix&lt;/code&gt;方法更详细的介绍可以参考这里：&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/&quot;&gt;理解CSS3 transform中的Matrix(矩阵)&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;CSS3 3D Transform&lt;/h3&gt;

&lt;p&gt;了解了2D Transform之后，3D Transform的概念也不会太难，他给HTML元素在x-y平面加上了z轴，我们一个个来看看：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;translate3d(tx,ty,tz)&lt;/code&gt;：他定义了一个3D的位移方法，增加了z轴的偏移量&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;translateZ(tz)&lt;/code&gt;：这个方法只在Z轴偏移，与&lt;code&gt;translateX()&lt;/code&gt;和&lt;code&gt;translateY()&lt;/code&gt;相似&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scale3d(sx,sy,sz)&lt;/code&gt;：在原有的&lt;code&gt;scale&lt;/code&gt;方法上增加了z轴的参数&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scaleZ(sz)&lt;/code&gt;：同理，只放大z轴，与&lt;code&gt;scaleX()&lt;/code&gt;和&lt;code&gt;scaleY()&lt;/code&gt;类似&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotate3d(rx,ry,rz)&lt;/code&gt;：将元素以给定参数的某一个轴方向旋转&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotateX(angle)，rotateY(angle)&lt;/code&gt;和&lt;code&gt;rotateZ(angle)&lt;/code&gt;：只按照某一个轴旋转，&lt;code&gt;rotate3d(1,0,0,30deg)&lt;/code&gt;相当于&lt;code&gt;rotateX(30deg)&lt;/code&gt;，其他类推。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;来看看例子：&lt;/p&gt;

&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;trans-3&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: translateZ(-200px);
&lt;/div&gt;
&lt;/div&gt;




&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;trans-31&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: translateZ(100px);
&lt;/div&gt;
&lt;/div&gt;




&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-31&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateX(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-32&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateY(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-33&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateZ(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;任何有3D变换的元素，不论最后只是做了2D的变换，或者什么都没做&lt;code&gt;translate3d(0,0,0)&lt;/code&gt;，都会触发浏览器去计算。不过，以后会更新优化也不一定。&lt;/p&gt;

&lt;h3&gt;Perspective&lt;/h3&gt;

&lt;p&gt;激活元素的3D空间，需要&lt;code&gt;perspective&lt;/code&gt;属性，写法有两种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform: perspective( 600px );
/**或者**/
perspective: 600px;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种不同写法，当应用元素只有一个时候，并没有区别，当有多个元素的时候，我们看看效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pers-red .item{
  background: red;
  transform: perspective( 400px ) rotateY(45deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;pers-con&quot; id=&quot;pers-red&quot;&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;


&lt;pre&gt;&lt;code&gt;#pers-blue {
  perspective: 400px;
}

#pers-blue .item{
  background: blue;
  transform: rotateY( 45deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;pers-con&quot; id=&quot;pers-blue&quot;&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;上面这两种写法，都触发了元素的3D行为，函数型的写法&lt;code&gt;transform:perspective(400px)&lt;/code&gt;适用于单个元素，会对每一个元素做3D视图的变换，而&lt;code&gt;perspective:400px&lt;/code&gt;的写法，需写在父元素上，然后以父元素的视角，对多个子元素进行3D变换，多个子元素共享同一个3D空间，可以自己打开console修改感受一下。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perspective&lt;/code&gt;的参数值，决定了3D效果的强烈程度，可以想象为距离多远去观察元素。值越大，观察距离就越远，同样的旋转值，看起来效果就弱一些；值越小，距离越近，3D效果就更强烈。&lt;/p&gt;

&lt;h4&gt;perspective-orgin&lt;/h4&gt;

&lt;p&gt;通常，对一个元素进行3D变换的时候，变换点都是元素的中心点，如果你想以其他的位置为变换点，那就可以用这个属性来做调整：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perspective-orgin: 20% 70%;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是默认值的&lt;code&gt;perspective-orign:50% 50%&lt;/code&gt;：&lt;/p&gt;

&lt;div id=&quot;transform1&quot;&gt;
&lt;div class=&quot;inner&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/city&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/food&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/people&quot; alt=&quot;Nature&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;这个是&lt;code&gt;perspective-orgin: 0% 50%;&lt;/code&gt;&lt;/p&gt;

&lt;div id=&quot;transform1&quot; sytle=&quot;-webkit-perspective-origin:0% 50%;perspective-origin:0% 50%&quot;&gt;
&lt;div class=&quot;inner&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/nature&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/animals&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/abstract&quot; alt=&quot;Nature&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;transform-style&lt;/h4&gt;

&lt;p&gt;这个参数用来共享父元素的3D空间，这样说起来有些抽象，下面第一个翻卡片的例子中会讲到。&lt;/p&gt;

&lt;h4&gt;backface-visibility&lt;/h4&gt;

&lt;p&gt;backface-visibility 属性可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当 backface-visibility 设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。该功能可帮助你模拟多面的对象，例如下例中使用的卡片。通过将 backface-visibility 设置为 hidden，可以确保只有正面可见。&lt;/p&gt;

&lt;h2&gt;CSS3 动画实例&lt;/h2&gt;

&lt;p&gt;下面例子中的代码，为了方便查看都没有写浏览器前缀，也没有加入其他的修饰属性，所以实际应用时，不要忘记哦，当然也可以直接console查看。&lt;/p&gt;

&lt;h3&gt;CSS3 翻纸牌&lt;/h3&gt;

&lt;p&gt;做一个翻纸牌的效果，结构很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;cardflip&quot;&amp;gt;
  &amp;lt;div id=&quot;card1&quot;&amp;gt;
    &amp;lt;div class=&quot;front&quot;&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;back&quot;&amp;gt;2&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.cardflip&lt;/code&gt;是整个3D效果的容器，&lt;code&gt;#card1&lt;/code&gt;是翻转效果的元素，&lt;code&gt;.front&lt;/code&gt;和&lt;code&gt;.back&lt;/code&gt;是翻转的两面。添加样式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cardflip {
    width: 200px;
    height: 260px;
    position: relative;
    perspective: 800px;
}

#card1 {
    width: 100%;
    height: 100%;
    position: absolute;
    transform-style: preserve-3d;
    transition: transform 1s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先给&lt;code&gt;#cardflip&lt;/code&gt;添加&lt;code&gt;perspective&lt;/code&gt;属性，这样才能触发3D变换，之后&lt;code&gt;#card1&lt;/code&gt;就在父元素的3D空间中了，用了&lt;code&gt;absolute&lt;/code&gt;来定位子元素，设置宽高都是&lt;code&gt;100%&lt;/code&gt;，这样就可以让&lt;code&gt;transform-origin&lt;/code&gt;在元素的中心点，这个后面再讨论。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;transform-style&lt;/code&gt;有两个值，一个是默认的&lt;code&gt;flat&lt;/code&gt;一个是&lt;code&gt;preserve-3d&lt;/code&gt;，由于&lt;code&gt;perspective&lt;/code&gt;的3D空间，只能作用于直接的子元素，那么&lt;code&gt;.front&lt;/code&gt;和&lt;code&gt;.back&lt;/code&gt;也需要&lt;code&gt;#cardflip&lt;/code&gt;的3D空间的话，就需要给&lt;code&gt;#card1&lt;/code&gt;添加这个属性，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 div{
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有&lt;code&gt;#card1 div&lt;/code&gt;元素共享了外层元素的3D空间之后，3D变换的属性才能生效，这时候的&lt;code&gt;backface-visibility&lt;/code&gt;才有效，设置为&lt;code&gt;hidden&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 .front {
    background: red;
}

#card1 .back {
    background: blue;
    transform: rotateY( 180deg );
}

#card1.flipped {
    transform: rotateY( 180deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为设置了&lt;code&gt;backface-visibility&lt;/code&gt;，而&lt;code&gt;.back&lt;/code&gt;默认就是以Y轴旋转了180度，空间想象一下，&lt;code&gt;.back&lt;/code&gt;就转到背面去了，所以&lt;code&gt;hidden&lt;/code&gt;属性生效，就看不到&lt;code&gt;.back&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;#card1&lt;/code&gt;添加了&lt;code&gt;.flipped&lt;/code&gt;的样式，&lt;code&gt;#card1&lt;/code&gt;以Y轴旋转了180度，这时候&lt;code&gt;.front&lt;/code&gt;转到了背面，而&lt;code&gt;.back&lt;/code&gt;从背面转到了前面，所以就完成了切换。这一段需要仔细的想一想。好了，看看下面的实例，点击即可翻转：&lt;/p&gt;

&lt;div id=&quot;cardflip&quot;&gt;
&lt;div id=&quot;card1&quot;&gt;
&lt;div class=&quot;front&quot;&gt;1&lt;/div&gt;
&lt;div class=&quot;back&quot;&gt;2&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;我们再给这个翻转加一些偏移的效果，看起来会不那么生硬。这就用到了&lt;code&gt;transform-origin&lt;/code&gt;，这个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 { transform-origin: left center; }

#card1.flipped {
  transform: translateX( 100% ) rotateY( 180deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认的&lt;code&gt;transform-origin&lt;/code&gt;是&lt;code&gt;center center&lt;/code&gt;，我们改成&lt;code&gt;left center&lt;/code&gt;之后，就不再以元素的x方向的中心为轴旋转，而是以元素的左边为Y轴旋转，所以还需要给整个&lt;code&gt;#card1&lt;/code&gt;加一个位移量&lt;code&gt;translate&lt;/code&gt;，值是&lt;code&gt;100%&lt;/code&gt;，就是元素本身的宽度。&lt;/p&gt;

&lt;p&gt;可以在console里面去掉&lt;code&gt;#card1.flipped&lt;/code&gt;的&lt;code&gt;translate&lt;/code&gt;帮助理解。&lt;/p&gt;

&lt;div id=&quot;cardflip1&quot;&gt;
&lt;div id=&quot;card2&quot;&gt;
&lt;div class=&quot;front&quot;&gt;1&lt;/div&gt;
&lt;div class=&quot;back&quot;&gt;2&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;这里有一点需要注意，当元素在z轴上有了位移，或者朝向负角度旋转，会导致元素在页面上无法被鼠标点击到，想像一下3D空间，这个元素已经位于整个页面平面的&lt;strong&gt;里面&lt;/strong&gt;，所以无法触及了。&lt;/p&gt;

&lt;h3&gt;CSS3 立方体&lt;/h3&gt;

&lt;p&gt;做完了反转卡片的效果，肯定还想做更炫的，来试试做一个立方体吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;section id=&quot;cube-con&quot;&amp;gt;
  &amp;lt;div id=&quot;cube&quot;&amp;gt;
    &amp;lt;figure class=&quot;front&quot;&amp;gt;1&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;back&quot;&amp;gt;2&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;right&quot;&amp;gt;3&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;left&quot;&amp;gt;4&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;top&quot;&amp;gt;5&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;bottom&quot;&amp;gt;6&amp;lt;/figure&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

#cube-con {
    width: 200px;
    height: 200px;
    position: relative;
    perspective: 1000px;
}

#cube {
    width: 100%;
    height: 100%;
    position: absolute;
    transform-style: preserve-3d;
}

#cube figure {
    width: 196px;
    height: 196px;
    display: block;
    position: absolute;
    border: 2px solid black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一部分和上一个例子没有太大的差别，应该都能理解每一个属性的含义了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube .front  { transform: rotateY(   0deg ) translateZ( 100px ); }
#cube .back   { transform: rotateX( 180deg ) translateZ( 100px ); }
#cube .right  { transform: rotateY(  90deg ) translateZ( 100px ); }
#cube .left   { transform: rotateY( -90deg ) translateZ( 100px ); }
#cube .top    { transform: rotateX(  90deg ) translateZ( 100px ); }
#cube .bottom { transform: rotateX( -90deg ) translateZ( 100px ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立方体的每一个面，经过&lt;code&gt;rotate&lt;/code&gt;旋转之后，就放置在了他该被放置的地方，但是这时候会发现，这些层叠加在一起，还没有成为一个立方体，这时候需要给Z轴一个位移，想象一下我们的视角点在&lt;code&gt;#cube&lt;/code&gt;正中间，拉伸z轴之后，&lt;code&gt;.right&lt;/code&gt;、&lt;code&gt;left&lt;/code&gt;等面就会有一定的角度，参考画画时候的透视，因为刚好在中心点，所以位移量就是宽度的一半。分步过程可以看&lt;a href=&quot;http://desandro.github.io/3dtransforms/examples/cube-01-steps.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为z轴拉伸之后，原来的对象会被放大一些，这样就会模糊掉，为了去掉这个影响，我们需要把立方体再推回原来的视角平面，于是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube { transform: translateZ( -100px ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成了立方体，想让某个面旋转到前方，只需转动整个立方体，不用去调整每个面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube.show-front  { transform: translateZ( -100px ) rotateY(    0deg ); }
#cube.show-back   { transform: translateZ( -100px ) rotateX( -180deg ); }
#cube.show-right  { transform: translateZ( -100px ) rotateY(  -90deg ); }
#cube.show-left   { transform: translateZ( -100px ) rotateY(   90deg ); }
#cube.show-top    { transform: translateZ( -100px ) rotateX(  -90deg ); }
#cube.show-bottom { transform: translateZ( -100px ) rotateX(   90deg ); }

/**还有过渡效果**/
#cube { transition: transform 1s; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;section id=&quot;cube-con&quot;&gt;&lt;/p&gt;

&lt;div id=&quot;cube&quot;&gt;
&lt;figure class=&quot;front&quot;&gt;1&lt;/figure&gt;
&lt;figure class=&quot;back&quot;&gt;2&lt;/figure&gt;
&lt;figure class=&quot;right&quot;&gt;3&lt;/figure&gt;
&lt;figure class=&quot;left&quot;&gt;4&lt;/figure&gt;
&lt;figure class=&quot;top&quot;&gt;5&lt;/figure&gt;
&lt;figure class=&quot;bottom&quot;&gt;6&lt;/figure&gt;
&lt;/div&gt;


&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;div id=&quot;cube-btn&quot;&gt;
&lt;button data-class=&quot;show-front&quot;&gt;Show Front&lt;/button&gt;
&lt;button data-class=&quot;show-back&quot;&gt;Show Back&lt;/button&gt;
&lt;button data-class=&quot;show-right&quot;&gt;Show Right&lt;/button&gt;
&lt;button data-class=&quot;show-left&quot;&gt;Show Left&lt;/button&gt;
&lt;button data-class=&quot;show-top&quot;&gt;Show Top&lt;/button&gt;
&lt;button data-class=&quot;show-bottom&quot;&gt;Show Bottom&lt;/button&gt;
&lt;/div&gt;


&lt;h3&gt;3D 旋转跑马灯&lt;/h3&gt;

&lt;p&gt;做幻灯片展示的方法有很多，我们用CSS3的3D技术来试试看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;section class=&quot;container&quot;&amp;gt;
  &amp;lt;div id=&quot;carousel&quot;&amp;gt;
    &amp;lt;figure&amp;gt;1&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;2&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;3&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;4&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;5&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;6&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;7&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;8&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;9&amp;lt;/figure&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

.container {
  width: 210px;
  height: 140px;
  position: relative;
  perspective: 1000px;
}

#carousel {
  width: 100%;
  height: 100%;
  position: absolute;
  transform-style: preserve-3d;
}

#carousel figure {
  display: block;
  position: absolute;
  width: 186px;
  height: 116px;
  left: 10px;
  top: 10px;
  border: 2px solid black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一段，没什么特别要说明的，基本的结构样式，以及之前重点说明过的&lt;code&gt;perspective&lt;/code&gt;和&lt;code&gt;preserve-3d&lt;/code&gt;。现在有9个卡片，要环绕成一圈，那么每个的角度就是&lt;code&gt;40deg&lt;/code&gt; （360/90）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel figure:nth-child(1) { transform: rotateY(   0deg ); }
#carousel figure:nth-child(2) { transform: rotateY(  40deg ); }
#carousel figure:nth-child(3) { transform: rotateY(  80deg ); }
#carousel figure:nth-child(4) { transform: rotateY( 120deg ); }
#carousel figure:nth-child(5) { transform: rotateY( 160deg ); }
#carousel figure:nth-child(6) { transform: rotateY( 200deg ); }
#carousel figure:nth-child(7) { transform: rotateY( 240deg ); }
#carousel figure:nth-child(8) { transform: rotateY( 280deg ); }
#carousel figure:nth-child(9) { transform: rotateY( 320deg ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，和立方体的例子到同样的步骤了，现在所有的卡片做了Y轴旋转，但因为观察的视角点没有变，所以看起来还是平面，如下这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/8b8af2c8jw1e84s4cel0uj208e05raa0.jpg&quot; alt=&quot;caro&quot; /&gt;&lt;/p&gt;

&lt;p&gt;立方体的位移很好计算，只要是宽度、高度、或者深度的一半就可以了，这个旋转的跑马灯应该怎么计算呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8b8af2c8jw1e84s5efyxej20f00b6aaj.jpg&quot; alt=&quot;caro-cmpu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从旋转跑马灯的上方观察，每个卡片的宽度是&lt;code&gt;210px&lt;/code&gt;，角度是&lt;code&gt;40deg&lt;/code&gt;，要计算到中心点的距离，根据旁边的三角形可得：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = 105 / tan(20deg) = 288px
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel figure:nth-child(1) {transform:rotateY(  0deg) translateZ(288px);}
#carousel figure:nth-child(2) {transform:rotateY( 40deg) translateZ(288px);}
#carousel figure:nth-child(3) {transform:rotateY( 80deg) translateZ(288px);}
#carousel figure:nth-child(4) {transform:rotateY(120deg) translateZ(288px);}
#carousel figure:nth-child(5) {transform:rotateY(160deg) translateZ(288px);}
#carousel figure:nth-child(6) {transform:rotateY(200deg) translateZ(288px);}
#carousel figure:nth-child(7) {transform:rotateY(240deg) translateZ(288px);}
#carousel figure:nth-child(8) {transform:rotateY(280deg) translateZ(288px);}
#carousel figure:nth-child(9) {transform:rotateY(320deg) translateZ(288px);}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了计算方法，如果要改变卡片的个数，或者宽度，只要按照那个公式再计算就好：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( ( ( Math.PI * 2 ) / numberOfPanels ) / 2 ) );
// or simplified to
var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( Math.PI / numberOfPanels ) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算好卡片的位置之后，然后旋转&lt;code&gt;#carousel&lt;/code&gt;就可以了，当然这个要用js来控制了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel{
    transform: translateZ( -288px ) rotateY( -160deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function(){
    $(&#39;#car-pre&#39;).click(function(){
        var deg = $(&#39;#carousel&#39;).attr(&#39;data-deg&#39;) || 0;
        deg = parseInt(deg)+40;

        var value = &#39;translateZ(-288px) rotateY(&#39;+deg+&#39;deg)&#39;;

        $(&#39;#carousel&#39;)
            .attr(&#39;data-deg&#39;,deg)
            .css({
                &#39;-webkit-transform&#39;:value
                ,&#39;-moz-transform&#39;:value
                ,&#39;-o-transform&#39;:value
                ,&#39;transform&#39;:value
            });
    });
    $(&#39;#car-next&#39;).click(function(){
        var deg = $(&#39;#carousel&#39;).attr(&#39;data-deg&#39;) || 0;
        deg = parseInt(deg)-40;

        var value = &#39;translateZ(-288px) rotateY(&#39;+deg+&#39;deg)&#39;;

        $(&#39;#carousel&#39;)
            .attr(&#39;data-deg&#39;,deg)
            .css({
                &#39;-webkit-transform&#39;:value
                ,&#39;-moz-transform&#39;:value
                ,&#39;-o-transform&#39;:value
                ,&#39;transform&#39;:value
            });
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;section id=&quot;caro-con&quot;&gt;&lt;div id=&quot;carousel&quot;&gt;&lt;figure&gt;1&lt;/figure&gt;&lt;figure&gt;2&lt;/figure&gt;&lt;figure&gt;3&lt;/figure&gt;&lt;figure&gt;4&lt;/figure&gt;&lt;figure&gt;5&lt;/figure&gt;&lt;figure&gt;6&lt;/figure&gt;&lt;figure&gt;7&lt;/figure&gt;&lt;figure&gt;8&lt;/figure&gt;&lt;figure&gt;9&lt;/figure&gt;&lt;/div&gt;&lt;/section&gt;&lt;/p&gt;

&lt;div id=&quot;car-btn&quot;&gt;
&lt;button id=&quot;car-pre&quot;&gt;&amp;lt; Prev&lt;/button&gt;
&lt;button id=&quot;car-next&quot;&gt;Next &amp;gt;&lt;/button&gt;
&lt;/div&gt;


&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;终于完成了这篇，梳理的过程对我自己很有提高，希望对你也能有些帮助，有兴趣可以关注我，期待下以后的博客~&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
